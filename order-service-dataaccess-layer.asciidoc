:toc: macro
toc::[]

= Order Service - Data Access Layer

In this chapter we are going to create database schema with initial data.
Then we will map it into entities model and provide operations for management of the entities.

== Create your component

After you have completed your own link:build-devon4j-application.asciidoc[devon4j app creation], we are going to create our first app component.

Going back to our example application, link:order-service.asciidoc[Order Service], we need to provide basic functionalities:

- increase price of the item with specified name.
- remove customer by id.
- create order with two positions and owner specified.
- find orders from given day with specified status.
- find items by name match (LIKE) ordered by name.

To accomplish that we are going to work over three entities: _ItemEntity_, _OrderEntity_, _CustomerEntity_.

Each of the entities will have autogenerated id and modificationCounter which specifies version number of the entity.

The Item will be defined with: name, description and price.

The Customer will be defined with: firstname and lastname. It will have also collection of it's orders.

The Order will be defined with: order positions, status, creation date, owner and price which is summary of all positions' prices.

In addition, we will have to represent two relationships:

The many to many relation between orders and items.

The one to many relation between order and customer.

=== The database

In the projects created with the devon4j archetype, we already have a complete data base schema that we can use as a model to create our own. By default we are going to work over the H2 database engine provided in the devon4j applications.

We have the /order-service-core/src/main/resources/db/type/h2/V0001Create_Sequence.sql, V0002Create_RevInfo.sql and V0003Create_BinaryObject.sql these tables are already used by default so donâ€™t delete them. We therefore also have /order-service-core/src/main/resources/db/migration/1.0/V0004Add_blob_data.sql. You can create your own schema table that your required. For e.g. db/type/h2/V0005__Create_OrderServiceSchema.sql.

You can check that your schema is valid running SpringBootApp.java which recreates schema after each run. Created schema can be found in the H2 console.

==== _Item_ table

Now we can add our first table Item in db/type/h2/V0005__Create_OrderServiceSchema.sql. In the case of OrderService, the items will provide: id, modificationCounter, name, description and price. So we need to represent that data in our table:

[source,sql]
----
CREATE TABLE Item (
  id                  BIGINT NOT NULL AUTO_INCREMENT,
  modificationCounter INTEGER NOT NULL,
  name                VARCHAR(255) NOT NULL,
  description         VARCHAR(255),
  price               DOUBLE NOT NULL,
  PRIMARY KEY (ID),
  CONSTRAINT UC_Item_name UNIQUE(name)
);
----

- id: the id for each item, automatically incremented using sequence HIBERNATE_SEQUENCE.
- modificationCounter: used internally by JPA to take care of the optimistic locking for us.
- name: the item's name.
- description: the item's description.
- price: the item's price.

We set also constraints:
- primary key for id to take care of it's uniqueness.
- unique key for name of the item.

==== _Customer_ table
Basing on _Item_ table provide also _Customer_ table with attributes as follows:
- id: the id for each customer, automatically incremented using sequence HIBERNATE_SEQUENCE.
- modificationCounter: used internally by JPA to take care of the optimistic locking for us.
- firstname: the customer's name.
- lastname: the customer's description.

We set also constraints:
- primary key for id to take care of it's uniqueness.

Types and specific column names are shown in the diagram.

==== _OrderSummary_ table
Basing on _Item_ table provide also _OrderSummary_ table with attributes as follows:
- id: the id for each order, automatically incremented using sequence HIBERNATE_SEQUENCE.
- modificationCounter: used internally by JPA to take care of the optimistic locking for us.
- price: price of whole order.
- ownerId: the customer's id which is owner of this order.
- creationDate: the order's creation date.
- status: status of the order.

We set also constraints:
- primary key for id to take care of it's uniqueness.
- foreign key to the_Customer_ table for column _ownerId_

Types and specific column names are shown in the diagram.

==== _OrderPosition_ table
_OrderPosition_ is a relational table used for keeping relation between the order and it's positions. It does not map into entity class.
- orderId: id of the _OrderSummary_ entry.
- itemId: if of the _Item_ entry.

We set also constraints:
- foreign key for orderId to show the connection to _OrderSummary_ table.
- foreign key for itemId to show the connection to _Item_ table.

Types and specific column names are shown in the diagram.

==== Mock data
Finally we can provide a certain amount of mock data to start our app. Add a new sql script /order-service-core/src/main/resources/db/migration/1.0/V0006__Add_OrderServiceData.sql adding sample data:

[source,sql]
----
INSERT INTO Item(id, ModificationCounter, name, description, price) VALUES (21, 0, 'spaghetti bolognese', 'Italy', 250);

INSERT INTO Customer(id, ModificationCounter, firstname, lastname) VALUES (31, 0, 'John', 'Travolta');

INSERT INTO OrderSummary(id, ModificationCounter, price, ownerId, creationDate, status) VALUES (41, 0, 671.10, 31, '2019-03-15', 'SERVED');

INSERT INTO OrderPosition(orderId, itemId) VALUES (41, 22);
----

You can provide your own data or use script which can be found here.

Run application and check that the data you provided is inserted into the database.

=== The core of the components
Now that we have defined the data base for our entities is the moment to start creating the code of the related components.

We are going to create entities with it's interfaces in new package _orderservice_ which will contain all objects specific for our application.

In order-service-core component create package _orderservice.dataaccess.api_ under com.devonfw.app.java.order where we will place our entities.

==== ItemEntity

Create new class ItemEntity.

Create there private attributes basing on the schema. For now, skip id and modificationCounter.
For each of them generate getters and setters (right click in ItemEntity -> Source -> Generate Getters and Setters).

Mark table with @Entity annotation and set also table name which should be mapped to this object.

[code,java]
----
@Entity(name="Item")
public class ItemEntity {
----

Generate interface and class hierarchy for _ItemEntity_ using CobiGen.

Choose Entity Infrastructure and click finish.

[code,java]
----
@Entity(name="Item")
public class ItemEntity extends ApplicationPersistenceEntity implements Item {
----

_ItemEntity_ extends now _ApplicationPersistenceEntity_ which has attributes id and modificationCounter needed for all our entities. Each of the entities should inherit from this class.

Check implementation of _ApplicationPersistenceEntity_,
[code,java]
----
@Override
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
public Long getId() {

  return this.id;
}

@Override
@Version
public int getModificationCounter() {

  return this.modificationCounter;
}
----
- @Id shows that this attribute will be the identifier of the entity. It is used by JPA to identify entity.
- @GeneratedValue shows that values for id will be automatically generated
- @Version defines modificationCounter attribute as version counter.

In component order-service-api com.devonfw.app.java.order.orderservice.common.api.Item, there is Item interface generated which contains method which have to be implemented by the Entity and later by transfer objects.

You can run the application and it should start correctly.

==== CustomerEntity

Next to the _ItemEntity_ create _CustomerEntity_ which should inherit from _ApplicationPersistenceEntity_.
Prepare attributes as shown in the schema (skip orders attribute until we create OrderEntity).
Generate getters and setters.
Generate  _Item_ interface for the entity same way we did it for _ItemEntity_.

==== OrderEntity

In component order-service-api com.devonfw.app.java.order.orderservice.common.api create _OrderStatus_ enum which will be used as status in _OrderEntity_.
[code,java]
----
public enum OrderStatus {
	NEW, PREPARING, PREPARED, SERVED, PAID, CANCELLED
}
----

Next to other entities create _OrderEntity_. It should also inherit from _ApplicationPersistenceEntity_.
Prepare attributes as shown in the schema.
Generate getters and setters.
Generate  _Order_ interface for the entity.

Above getters add needed annotations:

- As default, enum values are saved as Integer in the database. To have it's value as String, change is needed:
[code,java]
----
@Enumerated(EnumType.STRING)
public OrderStatus getStatus() {
  return status;
}
----
- Add mapping for relation to _CustomerEntity_:
[code,java]
----
@ManyToOne
	@JoinColumn(name = "ownerId")
	public CustomerEntity getOwner() {
		return owner;
	}
----
- Add mapping for relation to _ItemEntity_:
[code,java]
----
@ManyToMany
@JoinTable(name = "OrderPosition", joinColumns = @JoinColumn(name = "orderId", referencedColumnName = "id"), inverseJoinColumns = @JoinColumn(name = "itemId", referencedColumnName = "id"))
public Set<ItemEntity> getOrderPositions() {
  return orderPositions;
}
----
- Check method getOwnerId, it is marked with @Transient annotation to not map owner twice (since we have relation specified also by getOwner() method)

Adjust _CustomerEntity_ and add there relation to _OrderEntity_ with annotation showing that this relation is mapped only in OrderSummary table.
[code,java]
----
@OneToMany(mappedBy = "owner")
public Set<OrderEntity> getOrders() {
  return orders;
}
----

Run application and check that schema from database maps correctly into entities model.

=== link:order-service-logic-layer.asciidoc[Next chapter: Order Service - Business Logic Layer]
